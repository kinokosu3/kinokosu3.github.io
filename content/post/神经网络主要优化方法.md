---
title: 神经网络主要优化方法
date: 2018-05-02 15:48:50
tags:
    - TensorFlow
    - 神经网络
---
## 前言
`TensorFlow`实现

## 多层网络(使用多层的权重)

> 以下是三个隐含层的全连接方式的神经网络

```python
import tensorflow as tf

l1 = tf.matmul(x, w1)
l2 = tf.matmul(l1, w2)
y = tf.matmul(l2,w3)

```
<!--more-->

## 激活层(引入激活函数，让每一层去线性化)

> 激活函数有多种，例如常用的： tf.nn.relu tf.nn.tanh tf.nn.sigmoid tf.nn.elu

```python
import tensorflow as tf

a = tf.nn.relu(tf.matmul(x, w1) + biase1)
y = tf.nn.relu(tf.matmul(a, w2) + biase2)

```

## 损失函数

> 在分类问题中,交叉熵（cross entropy） 用于计算预测结果矩阵Y和实际结果矩阵Y_之间的距离

```python
import tensorflow as tf

cross_entropy = -tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y, 1e-10, 1.0)))

```

> 一般我们都会把交叉熵和softmax回归一起使用

```python
import tensorflow as tf

cross_entropy = tf.nn.softmax_cross_entropy_with_logits(y, y_)

```

> 如果是回归问题，我们使用均方误差

```python
import tensorflow as tf

mse_loss = tf.reduce_mean(tf.square(y_ - y))

# 与以下函数计算结果完全一致
dataset_size = 1000
mse_loss = tf.reduce_sum(tf.pow(y_ - y, 2)) / dataset_size

```

## 训练优化器

> 一般优化器的目标是优化权重W和偏差biases，最小化损失函数的结果 以下优化器会不断优化W和biases

```python
import tensorflow as tf

LEARNING_RATE = 0.001
mse_loss = tf.reduce_mean(tf.square(y_ - y))
train_op = tf.train.AdamOptimizer(LEARNING_RATE).minimize(mse_loss)

```

## 优化学习率

> 学习率设置过大可能导致无法收敛，学习率设置过小可能导致收敛过慢

```python
import tensorflow as tf

global_step = tf.Variable(0)
learning_rate = tf.train.exponential_decay(
    learning_rate=0.1, 
    global_step=global_step, 
    decay_steps=100, 
    decay_rate=0.96, 
    staircase=True, 
    name=None
)
train_op = tf.train.AdamOptimizer(learning_rate).minimize(loss, global_step=global_step)

```

## 过拟合问题(正则化)

> 避免训练出来的模型过分复杂，即模型记住了所有数据（包括噪声引起的误差）因此需要引入正则化函数叠加的方式，避免模型出现过拟合

```python

import tensorflow as tf

v_lambda = 0.001
w = tf.Variable(tf.random_normal([2, 1], stddev=1, seed=1))
y = tf.matmul(x, w)
mse_loss = tf.reduce_mean(tf.square(y_ - y) + tf.contrib.layers.l2_regularizer(v_lambda)(w))

```

## 滑动平均模型

> 用于控制模型的变化速度，可以控制权重W以及偏差biases 例如：avg_class.average(w) avg_class.average(biases)

```python
import tensorflow as tf

v1 = tf.Variable(0, dtype=tf.float32)
step = tf.Variable(0, trainable=False)
ema = tf.train.ExponentialMovingAverage(decay=0.99, num_updates=step)
# 每一次操作的时候，列表变量[v1]都会被更新
maintain_averages_op = ema.apply([v1]) 

with tf.Session() as sess:
    # 初始化
    init_op = tf.global_variables_initializer()
    sess.run(init_op)
    print(sess.run([v1, ema.average(v1)]))
    # 更新step和v1的取值
    sess.run(tf.assign(step, 10000))
    sess.run(tf.assign(v1, 10))
    sess.run(maintain_averages_op)
    print(sess.run([v1, ema.average(v1)]))

```