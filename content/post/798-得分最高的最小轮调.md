---
title: 798.得分最高的最小轮调
date: 2022-03-09 14:26:37
tags:
    - LeetCode
    - 前缀和
    - 差分数组
    - 动态规划
---

### 题目解读
根据题目可得下标大于或等于值获取一分，整个数组的值步数增大一步，数组的值就会抽象的向左移动，然后向左移动的值，填充到右边。然后根据规则计算分数得出哪个步数的分最多，返回步数。

### 思路
通过对比每次步数之后的变化，发现下标小于值的左移后依旧没有得分，下标大于值的左移后，直到碰到与自己相等的下标后才会失去值。共得出两种情况会出现分数变化，值从自己相等的下标位置左移、首位移动到末尾(因为值小于长度，所以值小于等于下标nums[i] < nums.length，所以移动到末尾的值必定小于或等于下标)。然后我们可以得出状态转移公式：当前分数 = 上一次分数 - 上一次有几个值与下标相等 + 1(首位移动到末尾的分数变化);

可以提前计算出每一步里有多少个值与下标相等的值，假如一个值现小于或等于下标，要将该值移动到相等下标的位置所需步数 下标 - 值。假如一个值大于下标，则该下标位置会在右边，所需步数首先 下标 + 数组长度 - 值。

然后通过遍历，筛选出最大的步数。

```golang
func bestRotation(nums []int) int {
    // index大于值或者等于记一分
    // 多个同分，选最小
	n := len(nums)
	val := 0
    // 计数当前已经得分的数
	for i:=0;i < n;i++ {
		if nums[i] <= i{
			val++
		}
	}
	steps := make([]int, n,n)
	for i :=0;i<n;i++{
		if nums[i] <= i{
            // 得分的时候，
			steps[i - nums[i]]++
		}else{
			steps[i + n - nums[i]]++
		}
	}
	ans := 0
	maxval := val
	for i :=1;i < n;i++{
		val = val - steps[i-1] + 1;
		if val > maxval{
			ans = i
			maxval = val
		}
	}
	return ans
}
```
